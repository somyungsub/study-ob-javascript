# 4. ES2015 이후 비동기식 프로그램의 제어 흐름 패턴

## 4-1. 프라미스

es6의 일부이며, node v4부터 사용가능

### 4-1-1. 프라미스란 무엇인가?

you don't know js 되새김.. callback의 불안정성(제어의 역전, 경합 조건, 실행되지 않는 경우)을 해소하는 비동기 interface<br>

```javascript
asyncOperation(arg)
  .then(result1 => {
    //다른 프라미스를 반환
    return asyncOperation(arg2);
  })
  .then(resu1t2 => {
    //값을 반환
    return "done";
  })
  .then(undefined, err => {
    //체인의 모든 에러를 여기서 처리함
  });
```

- result가 `값`이면 이행(fulfill) 값 x를 가지고 핸들러가 호출
- result가 `프라미스`이거나 `thenable`인 경우, result를 가지고 이행된 값(fulfillment value)을 가지고 핸들러가 호출
- 거부된 경우 에러핸들러(catch)가 호출

```javascript
// 실험 - result가 프라미스일 경우 바로 이행한다고오?

function p1(arg1) {
  console.log("p1의 실행"); // 3
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(arg1 + "너네 집");
    }, 1000);
  });
}

function p2() {
  console.log("첫번째"); // 1
  return Promise.resolve("던져부러");
}

p2()
  .then(res1 => {
    console.log("p2가 귀결되는 콜백~"); // 2
    return p1(res1);
  })
  .then(res2 => {
    console.log("p1가 귀결되는 콜백~"); // (1초 뒤) 4
    console.log("크크", res2); // 5
  });
```

### 4-1-2. Promises/A+ 구현

역사적으로 promise가 표준으로 채택되기 전에 다양한 promise 구현체(다양한 라이브러리)가 있었으며, 다른 구현체로부터 가져온 promise 객체들간에 프라미스 체인을 만들 수 없는 문제가 있었음<br>
JS 커뮤니티에서는 이러한 한계를 극복하고자 노력했으며, Promises/A+라는 사양(및 구현체)가 등장

- Bluebird(https://npmjs.org/package/bluebird)
- Q(https://npmjs.org/package/q)
- RSVP(https://npmjs.org/package/rsvp)
- Vow(https://npmjs.org/package/vow)
- When.js(https://npmjs.org/package/when)
- ES2015프라미스

일부 프라미스는 지연(defer) 메커니즘을 제공하는데, 자세히 알고싶으면 [여기 ㄱ ㄱ](https://github.com/kriskowal/q#using-deferreds) -> 비동기 객체를 만들고, 다른 callback의 결과를 인터셉트 하는 모양

### 4-1-3. Node.js 스타일 함수 프라미스화 하기

```javascript
function pFileSave() {
  return new Promise((resolve, reject) => {
    fs.save("파일이름", err => {
      if (err) {
        return reject(err);
      }
      return resolve("성공!");
    });
  });
}
```

위 원리로 promisify라는 함수를 작성

```javascript
// promisify
module.exports = function(callbackBasedApi) {
  return function promisified() {
    // 여기가 args
    const args = [].slice.call(arguments); // callback에 들어갈 args
    return new Promise((resolve, reject) => {
      //[1]
      args.push(function(err, result) {
        //[2]
        if (err) {
          return reject(err); //[3]
        }
        if (arguments.length <= 2) {
          //[4]
          resolve(result);
        } else {
          resolve([].slice.call(arguments, 1));
        }
      });
      callbackBasedApi.apply(null, args); //[5] -> null은 this 바인딩에 들어갈거, 실제 콜백에 전달될 첫째인자(err), 콜백에 들어갈 인자 모두 처리
    });
  };
};
```

### 4-1-4. 순차 실행

```javascript
const mkdirp = utilities.promisify(require("mkdirp"));

function download(url, filename) {
  console.log(`Downloading ${url}`);
  let body;
  return request(url)
    .then(response => {
      body = response.body;
      return mkdirp(path.dirname(filename));
    })
    .then(() => writeFile(filename, body))
    .then(() => {
      console.log(`Downloaded and saved: ${url}`);
      return body;
    });
}
```

콜백들을 promisify로 감싸서, promise 체인으로 순차 실행<br>
아래는 `순차 반복`

```javascript
function spiderLinks(currentUrl, body, nesting) {
  let promise = Promise.resolve();
  if (nesting === 0) {
    return promise;
  }
  const links = utilities.getPageLinks(currentUrl, body);
  links.forEach(link => {
    promise = promise.then(() => spider(link, nesting - 1)); // then 체인이 붙어있기 때문에, 일반적으로 forEach는 메인 스레드 영역에서 돌지만, then을 하려면 귀결 된 상태여야 하므로 순차성을 갖게 됨
  });

  return promise;
}
```

### 4-1-5. 병렬 실행

Promise.all

```javascript
const links = utilities.getPageLinks(currentUrl, body);
const promises = links.map(link => spider(link, nesting - 1)); // 모든 (spider가 반환하는) promise 인스턴스를 배열로 받아둠
// ex) promises = [new Promise(...), new Promise(...), new Promise(...)]

promises
  .all(promises)
  .then(resolveArr =>
    console.log(resolveArr[1], resolveArr[2], "... 넣은만큼")
  );
```

### 4-1-6. 제한된 병렬 실행

배치 개수만큼 병렬실행?
[코드](https://github.com/PacktPublishing/Node.js_Design_Patterns_Second_Edition_Code/tree/master/Chapter04/04_promises_limited_parallel_execution)

### 4.1.7 공개 API로 콜백과 프라미스 노출하기

콜백, 프라미스 둘 다 지원하도록 만들어보자~

```javascript
module.exports = function asyncDivision (dividend, divisor, cb) {
  return new Promise((resolve, reject) => {
    process.nextTick(() => {
      const result = dividend / divisor;
      if (isNaN(result) || !Number.isFinite(result)) {
        const error = new Error('Invalid operands'); if (cb) { cb(error); } //[2]
        return reject(error);
      }
      if (cb) { cb(null, result); } //[3]
      resolve(result);
    });
  });
});
```

```javascript
//콜백을 사용한 방법
asyncDivision(10, 2, (error, result) => {
  if (error) {
    return console.error(error);
  }
  console.log(result);
});
//프라미스를 사용한 방법
asyncDivision(22, 11)
  .then(result => console.log(result))
  .catch(error => console.error(error));
```

## 4-2. 제네레이터(Generator)
