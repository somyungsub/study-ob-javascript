# 6. 스코프
## 6-1. 컴파일러 이론
자바스크립트는 ‘동적’ 또는 ‘인터프리터’ 언어로 분류하나 사실은 ‘컴파일러 언어’
실질적으로 컴파일레이션은 코드가 실행되기 직전에 수행됨

### 6-1-1. 컴파일레이션 3단계
1. 토크나이징 / 렉싱 - 코드를 의미있는 조각으로 만드는 과정. var a = 2; -> var, a, =, 2, ;
2. 파싱 - 문법 구조를 반영하여 중첩 원소를 갖는 트리형태로 바꾸는 과정. 파싱의 결과로 만들어진 트리를 AST(추상 구문 트리)라 부름
3. 코드 생성 - AST를 컴퓨터에서 실행 코드로 바꾸는 과정.

## 6-2. 스코프 이해
엔진, 컴파일러, 스코프의 이해
* 엔진 - 컴파일레이션의 시작 - 끝까지 전 과정과 자바스크립트 프로그램 실행을 책임짐.(실질적인 런타임이라고 볼 수 있을듯)
* 컴파일러 - 파싱, 코드 생성 등
* 스코프 - 선언된 변수 목록을 작성하고 유지

### 6-2-1. 구문의 실행
```javascript
var a = 2;
```

* 컴파일러가 var a를 만나면 스코프 안에 변수 a가 있는지 체크
* 있으면 선언을 무시하고, 없으면 스코프 안에 a를 선언하라고 요청
* 그 후 컴파일러는 a = 2 대입문을 처리하기 위해 `엔진`이 실행할 수 있는 코드를 생성
* 엔진이 실행하는 코드는 먼저 스코프에 a라는 변수가 현재 스코프 내에서 접근할 수 있는지 확인
* 가능하다면 엔진은 변수 a를 사용, 아니라면 상위 스코프에서 접근여부 탐색
* 글로벌 스코프에서 까지 못찾으면 에러 발생

### 6-2-2. LHS와 RHS
엔진은 변수, 혹은 어떤 참조 값을 찾기위해 스코프에서 검색을 수행.

* LHS - 사실상 할당을 뜻하는 것으로 볼 수 있음
* RHS - 변수, 혹은 어떤 참조가 사용될 때, 어딘가 있는 값을 탐색하는 행위로 볼 수 있음

```javascript
function foo(a){
	console.log(a);
}
foo(2);
```

1. foo(2)가 실행되면서 참조할 수 있는 foo 함수가 있는지 RHS 검색
2. 스코프에 참조가능한 foo가 있으므로 오류 없이 foo(2) 실행
3. foo의 파라미터인 a는 LHS 검색으로 foo(a = 2)와 같이 할당
4. 참조할 수 있는 console 객체가 있는지 RHS 검색
5. console은 글로벌 스코프에 선언되어 있으므로 오류 없이 실행
6. console.log의 파라미터 a는 console.log(a = 2) LHS로 할당 (추측컨데 이 과정 전에 log(a)는 foo스코프 내에서 a=2를 RHS로 가져오게 될 것임)

## 6-3. 주의사항
호이스팅과 관련된 문제