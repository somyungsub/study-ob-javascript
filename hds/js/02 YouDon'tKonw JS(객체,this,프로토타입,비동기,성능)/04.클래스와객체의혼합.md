# 4. 클래스와 객체의 혼합

프로토타입 기반 언어에서의 OOP 기법<br>


## 4-1. 클래스 이론

OOP에서, 데이터는 자신을 기반으로 하는 동작과 연관되므로 데이터와 작동을 함께 잘 감싸는(캡슐화) 것이 올바른 설계라고 강조. 정규 컴퓨터 과학에서는 이를 `자료 구조`라고 표현하기도 함<br>
ex) 일련의 문자들을 `문자열(String)`이라고 하고 `단어(Word)` `어구(Phase)` 등으로 구성됨 -> 데이터 자체보다는 이 `데이터로 원하는 작업을 하는 것`이 관심사 -> length, indexOf, splice 등의 기능을 `String 클래스`의 메서드로 설계 -> 어떤 문자열이 주어지더라도 String 클래스의 인스턴스로 나타낼 수 있음.


### 4-1-1. 클래스 디자인 패턴

순회자(Iterator), 관찰자(Observer), 팩토리(Factory), 싱글턴(Singleton) 처럼 클래스도 디자인 패턴의 일종. (클래스 디자인 패턴 <-> 절차적(함수) 프로그래밍)<br>
'클래스가 과연 모든 코드의 근본적인 기초일까 아니면 코드를 선택적으로 추상화 한 것일까'


### 4-1-2. 자바스크립트 클래스

오래전부터 클래스와 비슷하게 생긴 new나 instanceof 등 구문 요소도 갖추고 있고, class라는 키워드가 명세에 추가되었지만, `js에는 클래스가 없다`<br>
클래스처럼 보이는 구문은 개발자들이 클래스 디자인 패턴으로 코딩할 수 있도록 자바스크립트 체계를 억지로 고친 것


## 4-2. 클래스 체계

클래스는 변수 세트, 메서드로 이루어져있지만 실제로 어떤 작업을 수행하는 건 아님. 인스턴스화해야 비로소 작업을 수행할 구체적인 자료 구조가 마련.<br>
(ex, stack 클래스는 그저 모든 스택이라면 마땅히 해야 할 기능을 추상화한 것이지 그 자체가 스택은 아님)


### 4-2-1. 건축

건축 아키텍트의 청사진(설계도)와 실제 건물(인스턴스)의 비유


### 4-2-2. 생성자

인스턴스는 보통 클래스명과 같은 이름의 생성자라는 특별한 메서드로 생성됨.


## 4-3. 클래스 상속

### 4-3-1. 다형성

상속받은 메서드를 오버라이드함<br>
자식 클래스가 마치 부모 클래스에 연결된 양 다형성을 혼동하지 X, 자식은 그저 부모에게서 자신이 필요한 내용을 베껴왔다. 부모 클래스를 기리키는 상대적 레퍼런스 super로 접근하는 것일 뿐


### 4-3-2. 다중 상속

마름모 문제. A -> B, A -> C, B -> D, C -> D 에서 drive() 메서드를 각각 오버라이드 했다면 D는 B와 C중 무엇을 참조할 것인가<br>
js에서 `다중 상속` 기능 따위는 처음부터 지원하지 않았다. 그러나 개발자는 다중 상속을 흉내(다음 절의 주제) 내기위해 꾸준히 노력해왔다.


## 4-4. 믹스인

js 객체는 상속받거나 인스턴스화해도 자동으로 복사 작업이 일어나지는 않는다.<br>
js엔 인스턴스로 만들 `클래스`란 개념 자체가 없고 오직 객체만 있음. 그리고 객체는 다른 객체에 복사되는 게 아니라 서로 연결됨<br>
Mixin은 클래스 복사 기능을 흉내 -> 명시적 믹스인, 암시적 믹스인


### 4-4-1. 명시적 믹스인

    fact: 자바스크립트는 클래스가 아예 없음, 그저 객체 뿐

객체 -> 객체로 프로퍼티를 수동으로 복사하는 유틸리티 작성<br>
js는 상대적 다형성을 제공하지 않기 때문에, 호출할 메소드가 부모 자식에 둘 다 있을때, 구별해서 호출하려면 절대적인 레퍼런스를 이용할 수 박에 없음. 이때 this에 대한 호출이 의도와 다르게 작용하여 .call(this)로 호출하도록 강제함.<br>
다형적 레퍼런스가 필요한 함수마다 명시적 의사다형성 방식의 연결을 명시적으로 일일이 만들어줘야 하는데 결과적으로 더 복잡하고 읽기 어렵고 관리하기 어려운 코드가 됨 -> 가능한 쓰지말자

### 4-4-2. 암시적 믹스인

암시적 this 바인딩을 이용함

```javascript
var Something = {
    cool: function() {
        this.greeting = "hi";
        this.count = this.count ? this.count + 1 : 1;
    }
};

Something.cool();
Something.greeting; // hi
Something.count; // 1

var Another = {
    cool: function(){
        Something.cool.call(this);
    }
};

Another.cool();
Another.greeting; // hi
Another.count; // 1
```

.call(this)같은 호출이 상대적 레퍼런스가 되지 않아 불안정하므로 신중히 처리해야 한다 -> 쓰지않는편이 좋다<br>
뭐야 둘다 쓰지 말래..